\documentclass[a4paper]{IEEEtran}
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage{graphicx}
\usepackage{mwe}
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{multicol}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},   commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}
\lstset{style=mystyle}

\title{Malware Analysis Report\\\Large{``Sample2.exe''}}
\author{
    \begin{tabular}{lr}
        Contro Filippo &VR437055\\
        Martini Michele &VR437056
    \end{tabular}
}

\begin{document}
	\maketitle
	\section{Executive summary}
	The malware ``Sample2.exe'' shows itself as a calculator app, with the appropriate icon and the expected behavior. Once it is opened by the user there is a simple GUI to perform basic arithmetic operations. Under the hood, however, the malware deactivates the Windows security center, makes many POST request to various internet sites and infects many other files in different locations, from the local folder to the system application's executable.
	
	The whole analysis process has been done on the provided virtual machine, which runs Windows 7 as operating system and contains a bunch of tools to make both static and dynamic analysis. The reverse engineering instead has been done on local machines.
	
	\section{Static analysis}
	We began the static analysis using \emph{PEStudio}\footnote{https://www.winitor.com/}, a tool which performs malware initial assessment, studying headers, sections and many other features of the executable, which is never executed.
	This first analysis gave us many indicators of probable malicious behavior.
	First of all, in the main view we noticed an \emph{entropy} value greater than 7, therefore it's likely that either the file has been packed or some sections has been obfuscated. Entropy is a measure of the order of the application, and it is calculated with statistical operations on the bytes; As explained in this article\footnote{http://n10info.blogspot.com/2014/06/entropy-and-distinctive-signs-of-packed.html} 
	
	``When a section of code of a file is compressed, the total entropy will increase while counting, i.e. , it will get closer to the standard sum of all bits - this will mean higher efficiency of information storage, i.e., possible compression of section of code.

	\begin{figure}[htp]
		\frame{\includegraphics[width=0.5\textwidth]{img/PEStudio-main.png}}
	\end{figure}

	The maximum value for entropy in PEStudio is 8, so this high value is a clear evidence of packing and/or obfuscation.
	
	The executable lacks of any certificate, while the information dealing with the version disguise it as a ``Windows calculator application file'', with the legal copyright by Microsoft, but there is not a date. The header instead has a compilation time-stamp dating August 2001.

	\subsection{Sections}

	\noindent The malware's code is made up of four sections:
	\begin{itemize}
		\item \textbf{.text}: the code in clear;
		\item \textbf{.data}: contains global variables;
		\item \textbf{.rsrc}: contains various resources, like images or icons;
		\item \textbf{.vmp0}: main section of the code, obfuscated to make reverse-engineering more difficult.
	\end{itemize}

	\begin{figure}[bp]
		\frame{\includegraphics[width=0.5\textwidth]{img/PEStudio-sections.png}}
	\end{figure}

	The last section is the largest with a file-ratio of 81.70\%; it has an entropy greater than 7  and PEStudio marks it as blacklisted. Moreover it is both writable and executable, which is often a malicious evidence, as it indicates self modifying code.
	
	After a little search on the internet we discovered that the name ``vmp'' refers to an obfuscation program called \emph{VMProtect}\footnote{https://vmpsoft.com/}. This program cypher the code exectuting it in a virtual CPU that is different from $x86$. This code obfuscator makes the reverse engineering extremely difficult.
	
	Nevertheless, the presence of these sections allows us to suppose that the code has not been packed and its high entropy is due only to the ``vmp0'' section, which is obfuscated. In order to validate this theory, we used \emph{PEiD}, a software whose goal is to detect any possible packing. This tool provides three levels of analysis varying in depth. Every level, however, gave us the same result: ``nothing found'', meaning that PEiD could not detect any packing mechanism.

	\begin{figure}[htp]
		\frame{\includegraphics[width=0.5\textwidth]{img/PEiD.png}}
	\end{figure}

	\subsection{Imports}
	
	The executable imports 6 libraries in total, and in particular PEStudio marks as blacklisted 21 functions belonging to \emph{Kernel32.dll} and \emph{user32.dll}. The most interesting are:

	\begin{itemize}
		\item \textbf{getModuleHandleA}, to call external files, such as \emph{dll} or \emph{exe};
		\item \textbf{loadLibraryA}, similar to that one above;
		\item \textbf{getProcAddress}, to get the address of a procedure inside a library;
		\item \textbf{getStartupInfoA}, to get information about startup;
		\item \textbf{getCommandLineW}, to let the program execute code on the command line;
	\end{itemize}
	
	Moreover there are also imports of functions dealing with \emph{Threads}, \emph{Clipboard} and \emph{Windows}.
	This suggests a suspicious behavior, due to the possibility of the program to access to all the libraries of the installed operating system.
	In the dynamic analysis we will see what actions are actually performed.
	The figure below contains all the blacklisted imports detected by PEStudio.
	
	\begin{figure}[htp]
		\frame{\includegraphics[width=0.5\textwidth]{img/PEStudio-imports.png}}
	\end{figure}
	
	%TODO Indicators and import analysis
	
	\subsection{Strings}
	Regarding strings we notice that those in .text, .data and .rsrc sections are in clear; furthermore many of them are function calls or values used to modify system registers.
	Followin them there are thousands of obfuscated strings, seemingly meaningless, which belong to the ``.vpm0'' section. This is another clue of code obfuscation.	
	
	
	\section{Dynamic analysis}
	
	The dynamic analysis consists of the execution of the malware in a controlled and isolated system to observe the behavior and the malicious actions performed.
	
	To accomplish this task we used \emph{VirtualBox}, a virtualization program that let us run a Windows 7 machine. VirtualBox handles the snapshots too, so that after every test the machine was restored to its initial state. The machine was also isolated from internet in order to avoid leaks.
	
	The machine was equipped with various tools to monitor the execution of the malware. The main ones were:
	\begin{itemize}
		\item \textbf{regshot}, to detect files and registers alterations between a time lapse;
		\item \textbf{procmon}, to log system functions called by the malware;
		\item \textbf{fakenet}, to track internet traffic in a simulated network.
	\end{itemize}
	These programs were executed with administrator permission in order to detect access to restricted locations.
	
	The tools can cooperate but they need to be executed is a certain schedule, in order to avoid conflicts among them. The analysis proceeded following these phases:
	\begin{enumerate}
		\item launch Fakenet;
		\item launch and setup Procmon;
		\item launch Regshot, setup path and run of its first shot;
		\item start Procmon analysis and launch of the malware;
		\item interaction with calculator by the GUI;
		\item stop Procmon tracking
		\item second Regshot shot;
		\item stop Fakenet;
	\end{enumerate}
	
	The first tests did not last too long: the GUI remained opened for just a few seconds. These tests did not give us evidence of malicious behavior, probably beacuse of the poor performance of the host machine.

	Then we ran other test leaving the malware run for a couple of minutes, leaving all the time needed to permorm bad actions. Then we collect the logs and analyzed them one by one.

	The first evidence of malicious behavior has been observed without any tools. After 20-30 seconds from the program execution the operating system prompted us a message about the \emph{Windows security center}; it was disabled and, from the control panel, it could not be re-activated. This is a seriuos threat to the security of the machine, leaving it opened to many other infections.

	\begin{figure}[htp]
		\frame{\includegraphics[width=0.5\textwidth]{img/securityCenter.png}}
	\end{figure}

	\subsection{Fakenet}

	FakeNet is a dynamic network analysis tool for malware analysts and penetration testers. It simulates a network logging the traffic generated by the machine. Every request is a file containing:

	\begin{itemize}
		\item Request type
		\item Destination URL
		\item Protocol
		\item User agent
	\end{itemize}

	The user agent field contains various informations about the local machine, such as architecture, operating system, product and so on. This string is
	\begin{quote}
		\texttt{User-Agent: Mozilla/4.0\\ (compatible; MSIE 28;\dots}
	\end{quote}
	There are other nubers dealing with the versions that have not been written for simplicity.

	The registered requests are over 900, whereas the destinations are 300, mainly russian sites. Unluckily the body is empty, and we cannot know the expected result due to the presence of Fakenet, which builds a fake http page as response to every request.

	Fakenet generated also a \emph{.pcap} file, containing the captured packets. Examinating it with \emph{Wireshark} we noticed all the TCP streams related to the POST requests, and other packets irrelevant with the malware, such as DHCP, ARP and DNS. One frequent message was a request to \emph{www.msftncs.com}, asking for a txt file called \emph{ncsi}. This sort of message is generated by Windows as a heat beat, keeping the machine constantly connected to the internet.

	This whole internet traffic should not be present, due to the absence of any socket library imported by the executable. Thus, in order to send packets over the network the malware needs to load external libraries dynamically, leaving a trace on the system that we capture using \emph{Procmon}.

	\subsection{Procmon}

	Process Monitor is an advanced monitoring tool for Windows that shows real-time file system, registry and process/thread activity. Procmon offers also a filtering function, and we set it to keep only the actions made by the malware.

	We can group these actions in 3 main sets: dll, registry and file.

	Dll stands for dynamic link library. These are particular files, shared among all the programs of the Windows operating system, that expose useful functions to programs which can call them to perform frequent operations. Every time that the malware loads a dll the system keeps a track of the action, thus using Procmon we were able to collect them all, identifying 46 different dlls used with the ``Load Image'' function. This primitive allows the program to load also other executables but, in our case, the only one loaded by the malware was the malware itself.

	Overall we counted 46 dll files loaded, among wich the most interesting are the cypher family, like \emph{cryptbase} and \emph{crypt32}, to handle cryptography and certificates.

	In order to perform network operations the malware needs a library to handle internet connections. This is made possible by the load of \emph{ws2\_32.dll}, which stands for web socket. This library provides the APIs (Application programming interface) needed to do POST request to all of the different URLs listed before.

	Among the actions concerning with the registers Procmon logged many Open-Read-Close operations on many different ones, but only a few were written directly by the malware. These ones are about the ``Language list'' and ``Internet settings''. This last one manage the permission over the internet among the 4 different zones (Intranet, Trusted, Internet, Restricted), setting the value to 0 which means ``Accept all''. This is dangerous as exposes the machine to possible attacks over the net.
	
	Procmon registered also accesses to thousands of file, and we noticed that many one of them were infected. The infection procedure followed these steps:

	\begin{itemize}
		\item Read the \emph{.exe} victim file.
		\item Write of the content plus the infected part in a \emph{.vir} file with the same name.
		\item Copy of the content of the \emph{.vir} file to the \emph{.exe} one changing the EOF location.
		\item Set of fake information on the executable such as creation an last access time.
		\item Delete the \emph{.vir} file.
	\end{itemize}

	After the infection the victim had another section called \emph{.vmp0}, having a similar size to the original one, which is both executable and writable. The infected files are hundreds and they are stored in many different locations. Many of them are common applications such as Windows Media Player, Internet Explorer, Windows Defender, Windows Mail, Windows Photo Viewer and other files in the System32 directory.

	\subsection{RegShot}
	
	Regshot is an open-source (LGPL) registry compare utility that allows you to quickly take a snapshot of your registry and then compare it with a second one - done after doing system changes or installing a new software product.

	In our use-case we recorded the first shot just before the execution of the malware. Then we ran it for some minutes and, after the program exit, we took the second shot, saving the result of the comparison in a \emph{.txt} file.

	This file contains variuos information about registries files and folders. The downside of Regshot is that it takes care of all the system changes, but it cannot associate each change to the process that caused it, so there is no way to separate the malware generated events from the system ones. The only clue that we can use is a comparison to the logfile generated by Procmon.

	Analyzing the output there are 6 new key added to the registry, 4 related to error reporting, one to instrumentation and one to the Security Center. This last one is the most interesting because it is the trace left by the deactivation of the security center that we noticed during the malware execution. In fact among the values added to the registries there is ``Enable Notifications'' set to zero.
	Then we found all the changes reported by Procmon about the internet zones, where every value is set to 0 (Allow anything).

	Another malicious evidence that we found is that the value ``Start'' of the \emph{wscsvc} service set to 4. This service is the security center, and the value 4 stands for disabled.

	The weired thing is that Procmon did not log those events, so they are not made by the malware itself, but by another process. In order to validate this hypotesis we ran Procmon and exectued the sample another time, keeping even the action perfomed by other processes. We discovered that those registry modifications had been made by ``services.exe'' and ``dllhost.exe''. They are not malicious process, but they are likely to be corrupted by the malware to deactivate the security center.

	The file attributes that are modified are those related to the infected files and thus they have a different creation time.

	\section{Reverse Engineering}

	In order to analyze the source code of the malware we used a tool called IDA, which is a feature rich, cross-platform, multi-processor disassembler and debugger developed by Hex-Rays. We also used OllyDBG, a 32-bit assembler-level debugger, which turned out fundamental to decode hidden instructions.

	The whole process of reverse engineering is very difficult due to the obfuscation of the code and to the presence of \emph{VMProtect} which encrypts the core of the program.
	Analyze .vmp0 section is not possible until the code in .text is executed, therefore we had to use OllyDBG on the malware's first section and obtain a decrypted version of the code. After that, we generated a dump of the memory so we could analyze the whole code using IDA.

	\subsection{Code rebuilding}

	The process of reverse engineering began with the disassembly phase, made possible by IDA. The tool shows the entry point and builds a cfg for each function. We analyzed the main one, obtaining a pseudo code of the function itself (See listing \ref{lst:pseudo-code}). This main procedure manages the de-obfuscation of the real malware. The \emph{.vmp0} section is decrypted through a cycle that perform an arithmetic xor of the code with a certain key. The cycle is repetead 7 times, but during the last one the key is incremented by one. The key is $0x58$. After this cycle there are two more that simply move portions of code. Next we observed a strange behavior: there are not return statements, but after the main procedure there are many functions. Following the code execution with a debugger we discovered that the program executes the code inside those functions like simple statements of the main procedure. Hence, the disassembler is unable to build a consistent cfg.
	At this point we decided to stop the code rebuilding and we began a debugging phase.

	\subsection{Debugging}

	In order to perform this analysis we began executing the malware with OllyDBG one instruction at the time, keeping procmon active alongside in order to detect malicious actions. Every time we found a function call we stepped over, tracking the results in order to isolate the interesting ones. Then we restarted the machine and repeat the whole process entering the target function, looking for nested calls to analyze.

	This malware uses a lot of external functions, imported from various dynamic link libraries. This functions are loaded with two primitives in Windows: \emph{loadLibrary} and \emph{getProcAddress}. The malware then stores the pointers to those functions as global values in the \emph{.data} section, thus the disassembler cannot statically detect the imported function. The only way to bypass it is to execute the malware with a debugger who can get the function name whenever it is called.

	Our aims were the infection procedure, which lets the malware copy its code inside other files, and the method used to stop the Windows Security Center.

	We discovered that the first thread was responsible for the GUI, whereas the second one did the real infection. In order to bypass loops we often put breakpoints after them. Eventually we achieved a procedure to debug the infection function:

	\begin{enumerate}
		\item  breakpoint in $0101273A$; then after the \emph{RET} the malware enters the obfuscated section.
		\item breakpoint in $010AAB30$; then there is the creation of the second thread which is the analyzed one.
		\item breakpoint in $010BD0A9$ which is the begin target function
	\end{enumerate}

	In particular we discovered that the thread calls FUN\_010ACABF, which then calls FUN\_0109F059, which then calls iteratively FUN\_010B0CAD; this last one contains FUN\_010BD0A9 which is the target function that performs the malicious actions.

	The infection function is FUN\_10BD636. It has only the target name as parameter. This procedure is huge, with too much code to reverse; it even contains a recursive call inside.

	The second target of our analysis is the deactivation of the security center. During the dynamic analysis we discovered that this was done by another process: \emph{services.exe}. Thus we repetead the debugging process keeping \emph{procmon} active, filtering the actions made by that process. We executed the malware step by step, finding that the instruction which performs the action is located at $010B10C7$. At this point the program calls an exteran function which is \emph{StartServiceA} from \emph{ADVAPI32.dll}. This instruction is executed two times without any apparent effect, but the third time immediately after the return the Security Center is turned off.
	Reading the documentation of the dll we found that this function is able to close services, but only if the caller has the rights to do it. However the malware is executed without administrative priviledge, so it's likely to have a priviledge escalation from previous functions.

	\section{Conclusion}

	Summing up the result of our analysis we can describe the malware as a polymorphic one, which performs variuos malicious actions such as internet connections, replications on other system programs and deactivates the security center. It disguise itself as a calculator, fooling the average user. The following table sums up its characteristics. The final evaluation given by both static and dynamic analysis considers the executable suspicious, and our analysis confirms the result.

	\begin{figure*}
		\centering
		\begin{subfigure}{0.49\textwidth}
		  \centering
		  \includegraphics[width=\textwidth]{img/summary.png}
		\end{subfigure}
		\hfill
		\begin{subfigure}{0.49\textwidth}
		  \centering
		  \includegraphics[width=\textwidth]{img/summary1.png}
		  \begin{minipage}{.1cm}
			\vfill
		  \end{minipage}
		\end{subfigure}
		%\caption{Summary of malware's main features and suspicious behaviours.}
	\end{figure*}

	\newpage
	\begin{lstlisting}[language=C, caption={Pseudo code of the decryption function.}, captionpos=b, label={lst:pseudo-code}]
void entry(void){
  unsigned short uVar1;
  int iVar2;
  unsigned int uVar3;
  int iVar4;
  unsigned int local_50;
  unsigned int local_48;
  int *local_3c;
  
  //Constant pointer to the code: 0x101E00B
  char *code_start = 0x183A+0x1FB4+0x101BADF-0x12C2;

  unsigned int i, j;

  for (i=0; i<7; i++){
    for (j=0x33cc1; j>0x12c5; j--){
    code_start[j] ^= (char)(i / 6) + 0x58U;
    }
  }

  for (i=0; i<0x24880; i++)
    DAT_0109c000[i] = DAT_0101f6cd[i];

  local_3c = &DAT_0104e6cd;

  for (i=0; i<0xa1c8; i++)
    DAT_011b9000[i] = DAT_010440cd[i];
}
	\end{lstlisting}

\end{document}