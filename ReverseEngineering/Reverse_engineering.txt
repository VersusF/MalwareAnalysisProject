### Thread Main:
Funzione che crea le threads: 010B2757
TODO: Mettere breakpoint dove c'è un LEAVE all'indirizzo 0101273A
      Dopo il return di questa funzione, il codice cambia completamente e
      insieme a lui anche tutti gli indirizzi (entriamo in .vmp0)
TODO: Analogo in 010AA9E7 (dentro a .vmp0) per poi fare return in 010AAB30
TODO: Disabilitare warning per breakpoint fuori dall'area del codice
--- Funzione malevola 01001F51 ---
Procedimento: Break in 0101273A -> Primo return per decifrare .vmp0
              Break in 010AAB30 -> Creazione della thread
              Entrare nella thread 2
              Break in 010BD0A9 -> Funzione che vogliamo analizzare
              
              Break in 010ACB47 -> la funzione malevola fa una call
                                   per creare i .vir

### Thread 2:
010AB86F: chiamata alla funzione che crea i .vir -> fun_010ACABF
Da qui in poi ci sono varie call ma analizziamo la fun

FUN_010ACABF:
  All'indirizzo 010ACB47 chiama FUN_0109F059 per scrivere i .vir e
  disabilitare il security center.
FUN_0109F059:
  All'indirizzo 0109F165 chiama FUN_010B0CAD che scrive i .vir iterativamente.
  Non a tutti i cicli fa delle WriteFile, a volte non fa niente, tuttavia dopo
  pochi istanti viene disabilitato il security center.
  Per uscire dal ciclo mettere un break a 0109F178.
FUN_010B0CAD:
  All'indirizzo 010B0F54 chiama FUN_010BD0A9, dopo la quale notiamo le infezioni, i file .vir, ma non disabilita il security center. Questo è strano in quanto le successive iterazioni fanno anche altre azioni malevole, ma non sappiamo in quale iterazione ciò accade. Questa è quindi la funzione da studiare.

Studiamo la funzione che chiamiamo TARGET: 010BD0A9
Al suo interno chiama
  - una funzione di string copy
  - una funzione 010B0B3B, al quale interno avrebbe altre chiamate a funzioni importate
    dinamicamente che però non esegue
  - una funzione 010AE48C, la quale non ha chiamate, ma solo controlli e cicli sulle
    stringhe passate come parametro